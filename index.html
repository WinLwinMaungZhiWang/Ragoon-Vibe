<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Smooth 3D Flipbook</title>

<style>
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:sans-serif}
  .stage{width:100%;height:100vh;display:flex;align-items:center;justify-content:center;padding:8px;box-sizing:border-box}
  #canvasWrap{width:100%;max-width:1100px;height:80vh;background:#111;border-radius:12px;overflow:hidden;position:relative}
  #overlayUI{position:absolute;left:12px;top:12px;z-index:30;display:flex;gap:8px}
  .btn{background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);color:#fff;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  .pager{position:absolute;right:12px;bottom:12px;background:rgba(0,0,0,0.5);padding:8px 12px;border-radius:10px;font-weight:600}
  .hint{position:absolute;left:50%;transform:translateX(-50%);bottom:10%;color:#aaa;font-size:13px}
  canvas{display:block}
</style>
</head>

<body>
<div class="stage">
  <div id="canvasWrap">
    <div id="overlayUI">
      <button id="prevBtn" class="btn">◀ Prev</button>
      <button id="nextBtn" class="btn">Next ▶</button>
    </div>
    <div id="pager" class="pager">0 / 0</div>
    <div class="hint">Swipe or click left/right</div>
  </div>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

/* CONFIG */
const images = [
  "/main/page1.png","/main/page2.png","./main/page3.png","./main/page4.png",
  "./main/page5.png","./main/page6.png","./main/page7.png"
];
const PAGE_WIDTH = 1.0;
const PAGE_HEIGHT = 1.5;
const SHELF_DEPTH = 0.02;

let scene, camera, renderer, clock;
let bookGroup;
let sheets = [];
let currentIndex = 0;

init();

async function init(){
  const container = document.getElementById("canvasWrap");
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);

  scene = new THREE.Scene();

  const aspect = container.clientWidth / container.clientHeight;
  camera = new THREE.PerspectiveCamera(40, aspect, 0.1, 20);
  camera.position.set(0,0,3);

  scene.add(new THREE.HemisphereLight(0xffffff, 0x222222, 0.9));

  clock = new THREE.Clock();

  bookGroup = new THREE.Group();
  scene.add(bookGroup);

  const loader = new THREE.TextureLoader();
  const texs = images.map(src => loader.load(src));

  buildSheets(texs);

  document.getElementById("nextBtn").onclick = () => flip(true);
  document.getElementById("prevBtn").onclick = () => flip(false);

  window.addEventListener("resize", onResize);

  animate();
}

function buildSheets(texs){
  const cols = 40, rows = 40;
  const geo = new THREE.PlaneGeometry(PAGE_WIDTH, PAGE_HEIGHT, cols, rows);

  for (let i=0; i<texs.length; i++){
    const mat = new THREE.MeshBasicMaterial({map: texs[i]});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(0,0, -i * SHELF_DEPTH);
    bookGroup.add(mesh);
    sheets.push({mesh, progress:0});
  }

  const scale = 1.6 / PAGE_HEIGHT;
  bookGroup.scale.set(scale, scale, scale);

  updatePager();
}

function flip(forward){
  const target = forward ? currentIndex : currentIndex - 1;
  if (target < 0 || target >= sheets.length) return;

  const sheet = sheets[target];
  const start = sheet.progress;
  const end = forward ? 1 : 0;
  const duration = 0.5;
  const startTime = performance.now();

  function animateFlipFrame(now){
    const t = Math.min((now - startTime)/ (duration*1000), 1);
    const p = start + (end-start)*ease(t);

    sheet.progress = p;
    sheet.mesh.rotation.y = -p * Math.PI;

    if (t < 1){
      requestAnimationFrame(animateFlipFrame);
    } else {
      if (forward) currentIndex++;
      else currentIndex--;
      updatePager();
    }
  }
  requestAnimationFrame(animateFlipFrame);
}

function ease(x){ return x<0.5 ? 4*x*x*x : 1 - Math.pow(-2*x+2,3)/2; }

function updatePager(){
  document.getElementById("pager").textContent = 
    (currentIndex+1) + " / " + sheets.length;
}

function animate(){
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

function onResize(){
  const container = document.getElementById("canvasWrap");
  renderer.setSize(container.clientWidth, container.clientHeight);
  camera.aspect = container.clientWidth / container.clientHeight;
  camera.updateProjectionMatrix();
}
</script>

</body>
</html>
