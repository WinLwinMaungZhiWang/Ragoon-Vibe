<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Menu Flipbook</title>
<style>
    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #111;
        font-family: sans-serif;
    }
    #view3D {
        width: 100vw;
        height: 100vh;
        position: fixed;
        top: 0;
        left: 0;
    }
</style>
</head>
<body>
<div id="view3D"></div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

//------------------------------------------------------
// CONFIG
//------------------------------------------------------
const images = [
    "page1.png",
    "page2.png",
    "page3.png",
    "page4.png",
    "page5.png",
    "page6.png"
];

//------------------------------------------------------
// THREE.JS SETUP
//------------------------------------------------------
const view3D = document.getElementById("view3D");
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
view3D.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
camera.position.set(0, 1.2, 4);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enableZoom = false;
controls.enablePan = false;
controls.target.set(0, 1, 0);
controls.update();

//------------------------------------------------------
// LIGHT
//------------------------------------------------------
scene.add(new THREE.AmbientLight(0xffffff, 1.2));

//------------------------------------------------------
// LOAD ALL IMAGES FIRST
//------------------------------------------------------
const loader = new THREE.TextureLoader();
const texPromises = images.map(src => new Promise((resolve, reject) => {
    loader.load(src, resolve, undefined, reject);
}));

const texs = await Promise.all(texPromises);

//------------------------------------------------------
// BUILD BOOK SPREADS
//------------------------------------------------------
const spreads = [];
for (let i = 0; i < images.length; i += 2) {
    spreads.push({ left: texs[i], right: texs[i + 1] || null });
}

const sheetW = 1.6;
const sheetH = 2.3;

const pages = [];

spreads.forEach((s, i) => {
    const group = new THREE.Group();
    group.position.x = i * 0.001;

    // Left page
    if (s.left) {
        const geoL = new THREE.PlaneGeometry(sheetW, sheetH);
        const matL = new THREE.MeshBasicMaterial({ map: s.left });
        const meshL = new THREE.Mesh(geoL, matL);
        meshL.position.x = -sheetW / 2;
        group.add(meshL);
    }

    // Right page
    if (s.right) {
        const geoR = new THREE.PlaneGeometry(sheetW, sheetH);
        const matR = new THREE.MeshBasicMaterial({ map: s.right });
        const meshR = new THREE.Mesh(geoR, matR);
        meshR.position.x = sheetW / 2;
        meshR.rotation.y = Math.PI;
        group.add(meshR);
    }

    group.position.y = 1;
    pages.push(group);
    scene.add(group);
});

//------------------------------------------------------
// FLIP ANIMATION
//------------------------------------------------------
let currentPage = 0;

function flipNext() {
    if (currentPage >= pages.length - 1) return;

    const page = pages[currentPage];
    const start = page.rotation.y;
    const end = start + Math.PI;
    animate(page, start, end);
    currentPage++;
}

function flipPrev() {
    if (currentPage <= 0) return;

    currentPage--;
    const page = pages[currentPage];
    const start = page.rotation.y;
    const end = start - Math.PI;
    animate(page, start, end);
}

function animate(target, from, to) {
    const D = 0.6;
    const t0 = performance.now();

    function frame() {
        const t = (performance.now() - t0) / (D * 1000);
        if (t >= 1) {
            target.rotation.y = to;
            return;
        }
        target.rotation.y = from + (to - from) * t;
        requestAnimationFrame(frame);
    }
    frame();
}

//------------------------------------------------------
// SWIPE CONTROLS
//------------------------------------------------------
let startX = 0;
let endX = 0;

window.addEventListener("touchstart", e => {
    startX = e.touches[0].clientX;
});
window.addEventListener("touchend", e => {
    endX = e.changedTouches[0].clientX;
    if (endX - startX > 50) flipPrev();
    if (startX - endX > 50) flipNext();
});

// CLICK / MOUSE
window.addEventListener("click", e => {
    if (e.clientX > window.innerWidth / 2) flipNext();
    else flipPrev();
});

//------------------------------------------------------
// RENDER LOOP
//------------------------------------------------------
function render() {
    requestAnimationFrame(render);
    controls.update();
    renderer.render(scene, camera);
}
render();

//------------------------------------------------------
// RESIZE
//------------------------------------------------------
window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>