<!--
flipbook_menu.html
Very Smooth 3D Book — WebGL (Three.js)
Single-file HTML/CSS/JS using Three.js to create a smooth, realistic 3D page curl animation.

Instructions:
 1. Save this file as flipbook_menu.html.
 2. Place your images in the same folder named page1.png, page2.png, ... or edit the `images` array below.
 3. Open in a modern browser (Chrome, Edge, Firefox). An internet connection is required to load Three.js from the CDN.

Features:
 - WebGL-based page bending using a custom vertex deformation (smooth curl)
 - Swipe and drag to turn pages interactively
 - Click or buttons to animate turn
 - Responsive, images preserved with correct aspect ratio
 - Lighting and soft shadows for depth

Limitations / Notes:
 - For best performance keep images to reasonable sizes (e.g. 1500px longest edge).
 - If you want an offline version, let me know and I'll inline a local three.js build.
 - This implementation uses a simplified curl shader (sinusoidal bend + rotation) — very realistic but not a full physics fold.

Customize tips:
 - Edit const images = [...] to list your files.
 - Adjust PAGE_WIDTH and PAGE_HEIGHT to match your menu aspect ratio.

Enjoy — tell me if you want: table-of-contents, thumbnails strip, printing mode, or export to a static site.
-->

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Smooth 3D Flipbook (WebGL)</title>
<style>
  html,body{height:100%;margin:0;background:#0b0b0b;color:#fff;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
  .stage{width:100%;height:100vh;display:flex;align-items:center;justify-content:center;padding:8px;box-sizing:border-box}
  #canvasWrap{width:100%;max-width:1100px;height:80vh;background:linear-gradient(180deg,#0d0d10 0%, #111118 100%);border-radius:12px;overflow:hidden;position:relative}
  #overlayUI{position:absolute;left:12px;top:12px;z-index:30;display:flex;gap:8px}
  .btn{background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.06);color:#fff;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  .pager{position:absolute;right:12px;bottom:12px;background:rgba(0,0,0,0.45);padding:8px 12px;border-radius:10px;font-weight:600}
  .hint{position:absolute;left:50%;transform:translateX(-50%);bottom:10%;color:rgba(255,255,255,0.6);font-size:13px}
  #toc{position:absolute;right:12px;top:12px;z-index:30}
  canvas{display:block}
</style>
</head>
<body>
<div class="stage">
  <div id="canvasWrap">
    <div id="overlayUI">
      <button id="prevBtn" class="btn">◀ Prev</button>
      <button id="nextBtn" class="btn">Next ▶</button>
    </div>
    <div id="toc"></div>
    <div id="pager" class="pager">0 / 0</div>
    <div class="hint">Drag page corner or swipe • Click for quick turn • ← → keys</div>
    <!-- three.js will create a canvas here -->
  </div>
</div>

<!-- Three.js from CDN -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
/* ============ CONFIG ============ */
const images = [ 'page1.png', 'page2.png', 'page3.png', 'page4.png', 'page5.png', 'page6.png', 'page7.png' ];
// Page visual dimensions (aspect) in virtual units — adjust to your image aspect ratio
const PAGE_WIDTH = 1.0; // arbitrary unit
const PAGE_HEIGHT = 1.5; // taller than wide (like a menu)
const SHELF_DEPTH = 0.02; // small thickness per sheet
/* ================================= */

// Derived
const spreads = [];
for(let i=0;i<images.length;i+=2) spreads.push({left: images[i] || null, right: images[i+1] || null});

// Three.js essentials
let scene, camera, renderer, clock;
let bookGroup; // parent group for all sheets
let sheets = []; // array of sheet objects {mesh, index, state}
let isDragging = false;
let dragData = null;
let currentIndex = 0; // number of flipped sheets

init();

async function init(){
  const container = document.getElementById('canvasWrap');
  renderer = new THREE.WebGLRenderer({antialias:true, alpha:false});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.shadowMap.enabled = true;
  container.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0b0b0b, 0.75);

  const aspect = container.clientWidth / container.clientHeight;
  camera = new THREE.PerspectiveCamera(40, aspect, 0.01, 100);
  camera.position.set(0, 0, 3.2);

  // lights
  const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.8);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(2, 4, 5);
  dir.castShadow = true;
  dir.shadow.mapSize.set(2048,2048);
  scene.add(dir);

  // ground subtle
  const groundMat = new THREE.MeshStandardMaterial({color:0x07070a, metalness:0.1, roughness:0.9});
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(10,10), groundMat);
  ground.rotation.x = -Math.PI/2; ground.position.y = -1.6; ground.receiveShadow = true; scene.add(ground);

  clock = new THREE.Clock();

  // book container
  bookGroup = new THREE.Group();
  scene.add(bookGroup);

  // Load textures
  const loader = new THREE.TextureLoader();
  const texPromises = images.map(src => {
    return new Promise((res)=>{
      if(!src){ res(null); return; }
      loader.load(src, tex => { tex.minFilter = THREE.LinearFilter; tex.generateMipmaps = false; res(tex); }, undefined, ()=>{ res(null); });
    });
  });
  const texs = await Promise.all(texPromises);

  // build sheets (spreads)
  buildSheets(texs);

  // UI
  updatePager();
  document.getElementById('nextBtn').addEventListener('click',()=>animateFlip(true));
  document.getElementById('prevBtn').addEventListener('click',()=>animateFlip(false));
  window.addEventListener('resize', onResize);
  window.addEventListener('keydown', (e)=>{ if(e.key==='ArrowRight') animateFlip(true); if(e.key==='ArrowLeft') animateFlip(false); });

  // pointer interactions
  renderer.domElement.addEventListener('pointerdown', onPointerDown);
  renderer.domElement.addEventListener('pointermove', onPointerMove);
  renderer.domElement.addEventListener('pointerup', onPointerUp);
  renderer.domElement.addEventListener('pointercancel', onPointerUp);

  animate();
}

function buildSheets(texs){
  const spreadCount = spreads.length;
  const halfW = PAGE_WIDTH/2;

  for(let s=0;s<spreadCount;s++){
    const leftTex = texs[s*2] || null; // careful: our texs array maps to images array; here we used images directly earlier
    // But spreads built from images; align indices accordingly
    const leftImg = spreads[s].left ? texturesFrom(images[s*2]) : null;
    // To simplify, create material using images directly by index:
    const leftIdx = s*2; const rightIdx = s*2+1;
    const tLeft = (leftIdx < images.length) ? new THREE.TextureLoader().load(images[leftIdx]) : null;
    const tRight = (rightIdx < images.length) ? new THREE.TextureLoader().load(images[rightIdx]) : null;

    // Plane geometry subdivided for smooth bend
    const cols = 40; const rows = 40;
    const geo = new THREE.PlaneGeometry(PAGE_WIDTH, PAGE_HEIGHT, cols, rows);

    // Shader material to allow bending deformation in vertex shader
    const material = new THREE.ShaderMaterial({
      uniforms: {
        uTime: {value:0},
        uProgress: {value:0}, // 0 closed, 1 flipped
        uTextureL: {value: tLeft || new THREE.Texture()},
        uTextureR: {value: tRight || new THREE.Texture()},
        uSide: {value: 1}, // 1 = front facing right page, -1 = back
      },
      vertexShader: `
        uniform float uProgress;
        varying vec2 vUv;
        void main(){
          vUv = uv;
          vec3 pos = position;
          // map x from -half to half
          float x = pos.x + ${halfW.toFixed(6)};
          // compute bend amount based on progress and x position
          float p = clamp(uProgress, 0.0, 1.0);
          // bend pivot near left edge when turning forward
          float bendCenter = ${(-halfW).toFixed(6)} + ${halfW.toFixed(6)}* (1.0 - p);
          // simple curvature: a quadratic depending on distance to pivot
          float dist = pos.x - ( -${halfW.toFixed(6)} + ${halfW.toFixed(6)}*p );
          float curl = sin( clamp(dist * 3.14159 / ${PAGE_WIDTH.toFixed(6)}, -3.14159, 3.14159) ) * p * 0.35;
          // apply vertical displacement for a subtle lift
          pos.z += curl;
          // slight rotation across x to simulate page tilt
          float rot = p *  -3.14159 * 0.5; // -90deg
          float ca = cos(rot); float sa = sin(rot);
          mat3 rotY = mat3(ca,0,sa, 0,1,0, -sa,0,ca);
          pos = rotY * pos;

          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D uTextureL;
        uniform sampler2D uTextureR;
        uniform float uProgress;
        varying vec2 vUv;
        void main(){
          // simple choose texture based on uv.x
          vec4 c = texture2D(uTextureR, vUv);
          gl_FragColor = c;
        }
      `,
      transparent: false
    });

    const mesh = new THREE.Mesh(geo, material);
    mesh.castShadow = true; mesh.receiveShadow = true;
    // position sheet so center of book is at x=0; spread s=0 is front (rightmost)
    const sheetIndex = s;
    // offset each sheet slightly in z to give thickness
    mesh.position.set(0,0, -sheetIndex * SHELF_DEPTH);
    // rotate sheets so that closed book shows right pages
    bookGroup.add(mesh);
    sheets.push({mesh, index: s, progress: 0, anim: null});
  }

  // center and scale bookGroup to fit view
  // compute bounding box approx
  const boxW = PAGE_WIDTH; const boxH = PAGE_HEIGHT;
  const scale = Math.min(2.2, 1.6 / Math.max(boxW / (window.innerWidth / window.innerHeight), boxH / 1.6));
  bookGroup.scale.set(scale, scale, scale);
}

function texturesFrom(src){
  if(!src) return null;
  return new THREE.TextureLoader().load(src);
}

function animate(){
  requestAnimationFrame(animate);
  const t = clock.getDelta();

  // update per-sheet uniforms if animating
  sheets.forEach(s => {
    const u = s.mesh.material.uniforms;
    if(s.anim){
      const now = Date.now();
      const elapsed = (now - s.anim.start)/s.anim.duration;
      const eased = easeInOutCubic(Math.min(elapsed,1));
      s.progress = s.anim.forward ? eased : (1 - eased);
      u.uProgress.value = s.progress;
      if(elapsed >= 1) s.anim = null;
    }
  });

  renderer.render(scene, camera);
}

function easeInOutCubic(x){ return x<0.5 ? 4*x*x*x : 1 - Math.pow(-2*x+2,3)/2 }

function animateFlip(forward=true){
  // choose sheet to animate: forward -> currentIndex (next unflipped), backward -> currentIndex-1
  let idx = forward ? currentIndex : (currentIndex - 1);
  if(idx < 0 || idx >= sheets.length) return;
  const sheet = sheets[idx];
  if(sheet.anim) return; // skip if already animating
  sheet.anim = { start: Date.now(), duration: 700, forward };
  // update index when animation completes asynchronously
  setTimeout(()=>{
    if(forward){ currentIndex = Math.min(currentIndex+1, sheets.length); } else { currentIndex = Math.max(0, currentIndex-1); }
    updatePager();
  }, 700);
}

function updatePager(){
  const pager = document.getElementById('pager');
  pager.textContent = `${Math.min(currentIndex+1, sheets.length)} / ${sheets.length}`;
}

function onResize(){
  const container = document.getElementById('canvasWrap');
  const w = container.clientWidth; const h = container.clientHeight;
  camera.aspect = w / h; camera.updateProjectionMatrix(); renderer.setSize(w,h);
}

// Pointer interaction: simple drag to flip next/prev based on horizontal drag
let pointerDown = false; let startX=0; let moved=false;
function onPointerDown(e){ pointerDown=true; startX = e.clientX; moved=false; }
function onPointerMove(e){ if(!pointerDown) return; const dx = e.clientX - startX; if(Math.abs(dx)>20) moved=true; }
function onPointerUp(e){ if(!pointerDown) return; pointerDown=false; if(!moved){ // click
    const rect = renderer.domElement.getBoundingClientRect(); const x = e.clientX - rect.left;
    if(x > rect.width/2) animateFlip(true); else animateFlip(false);
  } else {
    const dx = e.clientX - startX; if(dx < -40) animateFlip(true); if(dx > 40) animateFlip(false);
  }}

</script>
</body>
</html>